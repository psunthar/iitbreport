%%
%% This is file `iitbauthyr.bst',
%% Version: 1.1
%% Time-stamp: <2015-04-20 01:28:38 sunthar>
%% edited from file `apsrmp4-1long.bst',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% merlin.mbs  (with options: `head,ay,nat,lang,annote,pres,pres-bf,vonx,nm-revv1,jnrlst,nmft,nmft-def,fnm-def,nmfted,nmand-rm,lab,lab-def,and-rm,keyxyr,dt-beg,yr-com,aymth,dtrev,date-nil-x,note-yr,tit-qq,inproceedings-chapter,article-title-o,inproceedings-chapter,article-booktitle,article-series,jttl-rm,journal-address,book-bt,thesis-title-o,trtit-b,techreport-institution-par,vol-bf,vnum-sp,volp-com,pp-last,book-editor-booktitle,inbook-editor-booktitle,bookaddress,num-xser,number-cap,chapter-cap,series-number,numser-booktitle,ser-vol,ser-rm,volume-cap,ser-ed,jnm-x,pg-bk,book-chapter-pages,pub-par,ay-empty-pub-parens-x,pre-edn,school-par,isbn,issn,doi-link,doi,bkedcap,edby,blk-com,fin-endbibitem,pp,ed,abr,ednx,ord,jabr,and-com,etal-it,revdata,eprint,url,url-blk,translation,SLACcitation,numpages-x,url,url-prefix-x,bibinfo,bibfield,nfss,,{}')
%% physjour.mbs  (with options: `ay,nat,lang,annote,pres,pres-bf,vonx,nm-revv1,jnrlst,nmft,nmft-def,fnm-def,nmfted,nmand-rm,lab,lab-def,and-rm,keyxyr,dt-beg,yr-com,aymth,dtrev,date-nil-x,note-yr,tit-qq,inproceedings-chapter,article-title-o,inproceedings-chapter,article-booktitle,article-series,jttl-rm,journal-address,book-bt,thesis-title-o,trtit-b,techreport-institution-par,vol-bf,vnum-sp,volp-com,pp-last,book-editor-booktitle,inbook-editor-booktitle,bookaddress,num-xser,number-cap,chapter-cap,series-number,numser-booktitle,ser-vol,ser-rm,volume-cap,ser-ed,jnm-x,pg-bk,book-chapter-pages,pub-par,ay-empty-pub-parens-x,pre-edn,school-par,isbn,issn,doi-link,doi,bkedcap,edby,blk-com,fin-endbibitem,pp,ed,abr,ednx,ord,jabr,and-com,etal-it,revdata,eprint,url,url-blk,translation,SLACcitation,numpages-x,url,url-prefix-x,bibinfo,bibfield,nfss,,{}')
%% geojour.mbs  (with options: `ay,nat,lang,annote,pres,pres-bf,vonx,nm-revv1,jnrlst,nmft,nmft-def,fnm-def,nmfted,nmand-rm,lab,lab-def,and-rm,keyxyr,dt-beg,yr-com,aymth,dtrev,date-nil-x,note-yr,tit-qq,inproceedings-chapter,article-title-o,inproceedings-chapter,article-booktitle,article-series,jttl-rm,journal-address,book-bt,thesis-title-o,trtit-b,techreport-institution-par,vol-bf,vnum-sp,volp-com,pp-last,book-editor-booktitle,inbook-editor-booktitle,bookaddress,num-xser,number-cap,chapter-cap,series-number,numser-booktitle,ser-vol,ser-rm,volume-cap,ser-ed,jnm-x,pg-bk,book-chapter-pages,pub-par,ay-empty-pub-parens-x,pre-edn,school-par,isbn,issn,doi-link,doi,bkedcap,edby,blk-com,fin-endbibitem,pp,ed,abr,ednx,ord,jabr,and-com,etal-it,revdata,eprint,url,url-blk,translation,SLACcitation,numpages-x,url,url-prefix-x,bibinfo,bibfield,nfss,,{}')
%% photjour.mbs  (with options: `ay,nat,lang,annote,pres,pres-bf,vonx,nm-revv1,jnrlst,nmft,nmft-def,fnm-def,nmfted,nmand-rm,lab,lab-def,and-rm,keyxyr,dt-beg,yr-com,aymth,dtrev,date-nil-x,note-yr,tit-qq,inproceedings-chapter,article-title-o,inproceedings-chapter,article-booktitle,article-series,jttl-rm,journal-address,book-bt,thesis-title-o,trtit-b,techreport-institution-par,vol-bf,vnum-sp,volp-com,pp-last,book-editor-booktitle,inbook-editor-booktitle,bookaddress,num-xser,number-cap,chapter-cap,series-number,numser-booktitle,ser-vol,ser-rm,volume-cap,ser-ed,jnm-x,pg-bk,book-chapter-pages,pub-par,ay-empty-pub-parens-x,pre-edn,school-par,isbn,issn,doi-link,doi,bkedcap,edby,blk-com,fin-endbibitem,pp,ed,abr,ednx,ord,jabr,and-com,etal-it,revdata,eprint,url,url-blk,translation,SLACcitation,numpages-x,url,url-prefix-x,bibinfo,bibfield,nfss,,{}')
%% merlin.mbs  (with options: `tail,ay,nat,lang,annote,pres,pres-bf,vonx,nm-revv1,jnrlst,nmft,nmft-def,fnm-def,nmfted,nmand-rm,lab,lab-def,and-rm,keyxyr,dt-beg,yr-com,aymth,dtrev,date-nil-x,note-yr,tit-qq,inproceedings-chapter,article-title-o,inproceedings-chapter,article-booktitle,article-series,jttl-rm,journal-address,book-bt,thesis-title-o,trtit-b,techreport-institution-par,vol-bf,vnum-sp,volp-com,pp-last,book-editor-booktitle,inbook-editor-booktitle,bookaddress,num-xser,number-cap,chapter-cap,series-number,numser-booktitle,ser-vol,ser-rm,volume-cap,ser-ed,jnm-x,pg-bk,book-chapter-pages,pub-par,ay-empty-pub-parens-x,pre-edn,school-par,isbn,issn,doi-link,doi,bkedcap,edby,blk-com,fin-endbibitem,pp,ed,abr,ednx,ord,jabr,and-com,etal-it,revdata,eprint,url,url-blk,translation,SLACcitation,numpages-x,url,url-prefix-x,bibinfo,bibfield,nfss,,{}')
%% ----------------------------------------
%% *** REVTeX-compatible RMP long 2009-10-08 ***
%% 
%% Copyright 1994-2007 Patrick W Daly
 % ===============================================================
 % IMPORTANT NOTICE:
 % This bibliographic style (bst) file has been generated from one or
 % more master bibliographic style (mbs) files, listed above.
 %
 % This generated file can be redistributed and/or modified under the terms
 % of the LaTeX Project Public License Distributed from CTAN
 % archives in directory macros/latex/base/lppl.txt; either
 % version 1 of the License, or any later version.
 % ===============================================================
 % Name and version information of the main mbs file:
 % \ProvidesFile{merlin.mbs}[2008/01/17 4.21 (PWD, AO, DPC)]
 %   For use with BibTeX version 0.99a or later
 %-------------------------------------------------------------------
 % This bibliography style file is intended for texts in ENGLISH
 % This is an author-year citation style bibliography. As such, it is
 % non-standard LaTeX, and requires a special package file to function properly.
 % Such a package is    natbib.sty   by Patrick W. Daly
 % The form of the \bibitem entries is
 %   \bibitem[Jones et al.(1990)]{key}...
 %   \bibitem[Jones et al.(1990)Jones, Baker, and Smith]{key}...
 % The essential feature is that the label (the part in brackets) consists
 % of the author names, as they should appear in the citation, with the year
 % in parentheses following. There must be no space before the opening
 % parenthesis!
 % With natbib v5.3, a full list of authors may also follow the year.
 % In natbib.sty, it is possible to define the type of enclosures that is
 % really wanted (brackets or parentheses), but in either case, there must
 % be parentheses in the label.
 % The \cite command functions as follows:
 %   \citet{key} ==>>                Jones et al. (1990)
 %   \citet*{key} ==>>               Jones, Baker, and Smith (1990)
 %   \citep{key} ==>>                (Jones et al., 1990)
 %   \citep*{key} ==>>               (Jones, Baker, and Smith, 1990)
 %   \citep[chap. 2]{key} ==>>       (Jones et al., 1990, chap. 2)
 %   \citep[e.g.][]{key} ==>>        (e.g. Jones et al., 1990)
 %   \citep[e.g.][p. 32]{key} ==>>   (e.g. Jones et al., p. 32)
 %   \citeauthor{key} ==>>           Jones et al.
 %   \citeauthor*{key} ==>>          Jones, Baker, and Smith
 %   \citeyear{key} ==>>             1990
 %---------------------------------------------------------------------

FUNCTION {id.bst} {"Merlin.mbs v4.21 2009-07-09. "}
ENTRY
{
    address
    annote
    archive
    archivePrefix
    author
    bookaddress
    booktitle
    chapter
    collaboration
    doi
    edition
    editor
    eid
    eprint
    howpublished
    institution
    isbn
    issn
    journal
    key
    language
    month
    note
    number
    organization
    pages
    primaryClass
    publisher
    school
    SLACcitation
    series
    title
    translation
    type
    url
    volume
    year
}{
}{
    label
    extra.label sort.label
    short.list
}

INTEGERS
{
  output.state before.all
  after.word after.punctuation
  after.sentence after.block
}

INTEGERS
{
  punctuation.state punctuation.no punctuation.space punctuation.yes
}

STRINGS { bibfield output.bibfield }
FUNCTION {not}
{   { #0 }
    { #1 }
  if$
}

FUNCTION {and}
{   'skip$
    { pop$ #0 }
  if$
}

FUNCTION {or}
{   { pop$ #1 }
    'skip$
  if$
}

FUNCTION {non.stop}
{ duplicate$
   "}" * add.period$
   #-1 #1 substring$ "." =
}

FUNCTION {init.state.consts}
{
  #0 'before.all        :=
  #1 'after.word        :=
  #2 'after.punctuation :=
  #3 'after.sentence    :=
  #4 'after.block       :=
  #0 'punctuation.no    :=
  #1 'punctuation.space :=
  #2 'punctuation.yes   :=
  "" 'bibfield          :=
  "" 'output.bibfield   :=
}

STRINGS { s t}
FUNCTION {block.punctuation}
{ ""
  "," *
}

FUNCTION {word.space}
{
  "\ "
}

FUNCTION {show.stackstring.one}{
  "(" *
  output.state int.to.str$ *
    "," * punctuation.state int.to.str$ *
  ")" * top$
  duplicate$ "1(" swap$ * ")" * top$
}

FUNCTION {show.stackstring.two}{
  "(" *
  output.state int.to.str$ *
    "," * punctuation.state int.to.str$ *
  ")" * top$
  swap$
  duplicate$ "1(" swap$ * ")" * top$
  swap$
  duplicate$ "2(" swap$ * ")" * top$
}

FUNCTION {bibfield.command}{ "\bibfield"}

FUNCTION {output.nonnull}
{
  swap$
  output.state after.word =
    {
      block.punctuation *
      word.space *
    }
    {
      output.state after.punctuation =
        {
          word.space *
        }
        {
          output.state after.block = output.state after.sentence = or
            {
              add.period$
              "\EOS\ " *
            }{
            }
          if$
        }
      if$
    }
  if$
  output.bibfield duplicate$ empty$ 'pop$
    {
      bibfield.command
      "{" * swap$ * "}{%" * write$ newline$
      "  "  swap$ * "}%"  * write$ newline$
      "  "
    }
  if$
  write$
  bibfield 'output.bibfield := "" 'bibfield :=
  output.state after.block =
    {
      newline$
      "\newblock " write$
    }
    'skip$
  if$
  punctuation.state duplicate$
  punctuation.yes 'punctuation.state :=
  punctuation.no =
    { pop$ before.all }
    { punctuation.yes = { after.word }{ after.punctuation } if$ }
  if$
  'output.state :=
}

FUNCTION {output}
{ duplicate$ empty$
    {
      pop$
  "" 'bibfield :=
    }
    'output.nonnull
  if$
}

FUNCTION {output.check}
{ swap$
  duplicate$ empty$
    { pop$ "empty " swap$ * " in " * cite$ * warning$ }
    { swap$ pop$ output.nonnull }
  if$
}

FUNCTION {bbl.open} { "\BibitemOpen" }

FUNCTION {bbl.shut} { "\BibitemShut" }

FUNCTION {bibitem.shut.stop} { bbl.shut "{Stop}%" * }

FUNCTION {bibitem.shut.nostop} { bbl.shut "{NoStop}%" * }

FUNCTION {bibitem.shut}
{
  non.stop
    {
  bibitem.shut.nostop *
    }{
  bibitem.shut.stop *
    }
  if$
}

FUNCTION {html.itag} {
  "p"
}

FUNCTION {html.ltag} {
  ""
}

FUNCTION {output.SLACcitation}
{ SLACcitation empty$
    'skip$
    {
      newline$
      SLACcitation write$
    }
  if$
}

FUNCTION {fin.entry}
{
  non.stop swap$
  "%" * write$ newline$
    { "{NoStop}" }
    { "{Stop}" }
  if$
  annote missing$
  {
   "  \bibAnnoteFile" swap$ * "{" * cite$ * "}%"  *
  }{
   "  \bibAnnote"     swap$ * "{" * cite$ * "}{" * annote * add.period$ "}%" *
  }
  if$
  write$
    output.SLACcitation
}

FUNCTION {new.block}
{ output.state before.all =
    'skip$
    { after.block 'output.state := }
  if$
}

FUNCTION {new.block.comma}
{
}

FUNCTION {new.sentence}
{ output.state after.block = output.state before.all = or
    'skip$
    { after.sentence 'output.state := }
  if$
}

FUNCTION {new.sentence.comma}
{
}

FUNCTION {sentence.or.colon}
{
  new.sentence
}

FUNCTION {add.blank}
{
  word.space *
  before.all 'output.state :=
}

FUNCTION {no.blank.or.punct}
{
   "\hspace{0pt}" *
   before.all 'output.state :=
}

FUNCTION {date.block}
{
  new.block.comma
  skip$
}

FUNCTION {new.block.checkb}
{ empty$
  swap$ empty$
  and
    'skip$
    'new.block
  if$
}

FUNCTION {field.or.null}
{ duplicate$ empty$
    { pop$ "" }
    'skip$
  if$
}

FUNCTION {emphasize}
{
  duplicate$ empty$
    { pop$ "" }
    {
      "\emph{" swap$ * "}" *
    }
  if$
}

FUNCTION {bolden}
{ duplicate$ empty$
    { pop$ "" }
    { "\textbf{" swap$ * "}" * }
  if$
}

FUNCTION {bib.name.font}
{
  duplicate$ empty$
    { pop$ "" }
    {
    "\bibnamefont{" swap$ * "}" *
    }
  if$
}

FUNCTION {bib.fname.font}
{
  duplicate$ empty$
    { pop$ "" }
    {
    "\bibfnamefont{" swap$ * "}" *
    }
  if$
}

FUNCTION {cite.name.font}
{
  duplicate$ empty$
    { pop$ "" }
    {
    "\citenamefont{" swap$ * "}" *
    }
  if$
}

FUNCTION {tie.or.space.prefix}
{ duplicate$ text.length$ #3 <
    { "~" }
    { word.space }
  if$
  swap$
}

FUNCTION {capitalize}
{
  "u" change.case$ "t" change.case$
}

FUNCTION {space.word}
{ word.space swap$ * word.space * }

 % Here are the language-specific definitions for explicit words.
 % Each function has a name bbl.xxx where xxx is the English word.
 % The language selected here is ENGLISH
FUNCTION {bbl.and}
{
  "and"
}

FUNCTION {bbl.etal}
{
  "et~al."
}

FUNCTION {bbl.editors}
{
  "eds."
}

FUNCTION {bbl.editor}
{
  "ed."
}

FUNCTION {bbl.edby}
{ "edited by" }

FUNCTION {bbl.edition}
{
  "ed."
}

FUNCTION {bbl.volume}
{
  "vol."
}

FUNCTION {bbl.of}
{ "of" }

FUNCTION {bbl.number}
{
  "no."
}

FUNCTION {bbl.nr}
{ "no." }

FUNCTION {bbl.in}
{ "in" }

FUNCTION {bbl.pages}
{
  "pp."
}

FUNCTION {bbl.page}
{
  "p."
}

FUNCTION {bbl.eidpp}
{ "pages" }

FUNCTION {bbl.chapter}
{
  "chap."
}

FUNCTION {bbl.techrep}
{
  "Tech. Rep."
}

FUNCTION {bbl.mthesis}
{ "Master's thesis" }

FUNCTION {bbl.phdthesis}
{ "Ph.D. thesis" }

FUNCTION {bbl.first}
{
  "1st"
}

FUNCTION {bbl.second}
{
  "2nd"
}

FUNCTION {bbl.third}
{
  "3rd"
}

FUNCTION {bbl.fourth}
{
  "4th"
}

FUNCTION {bbl.fifth}
{
  "5th"
}

FUNCTION {bbl.st}
{ "st" }

FUNCTION {bbl.nd}
{ "nd" }

FUNCTION {bbl.rd}
{ "rd" }

FUNCTION {bbl.th}
{ "th" }

MACRO {jan} {"Jan."}

MACRO {feb} {"Feb."}

MACRO {mar} {"Mar."}

MACRO {apr} {"Apr."}

MACRO {may} {"May"}

MACRO {jun} {"Jun."}

MACRO {jul} {"Jul."}

MACRO {aug} {"Aug."}

MACRO {sep} {"Sep."}

MACRO {oct} {"Oct."}

MACRO {nov} {"Nov."}

MACRO {dec} {"Dec."}

FUNCTION {bbl.url.prefix}
{
  "\urlprefix"
}

FUNCTION {eng.ord}
{ duplicate$ "1" swap$ *
  #-2 #1 substring$ "1" =
     { bbl.th * }
     { duplicate$ #-1 #1 substring$
       duplicate$ "1" =
         { pop$ bbl.st * }
         { duplicate$ "2" =
             { pop$ bbl.nd * }
             { "3" =
                 { bbl.rd * }
                 { bbl.th * }
               if$
             }
           if$
          }
       if$
     }
   if$
}

FUNCTION {bibinfo.command} { "\bibinfo" }

FUNCTION {bibinfo.check}
{ swap$
  duplicate$ missing$
    {
      pop$
      pop$ ""
    }{
      duplicate$ empty$
        {
          swap$ pop$
        }{
          swap$
          bibinfo.command " {" * swap$ * "} {" * swap$ * "}" *
        }
      if$
    }
  if$
}

FUNCTION {bibinfo.warn}
{ swap$
  duplicate$ missing$
    {
      swap$ "missing " swap$ * " in " * cite$ * warning$ pop$
      ""
    }{
      duplicate$ empty$
        {
          swap$ "empty " swap$ * " in " * cite$ * warning$
        }{
          swap$
          bibinfo.command " {" * swap$ * "} {" * swap$ * "}" *
        }
      if$
    }
  if$
}

FUNCTION {archiv.base}
{
  "http://arxiv.org/abs"
}

FUNCTION {archiv.prefix.base}
{
  "arXiv"
}

FUNCTION {eprint.command}
{
  "\Eprint"
}

FUNCTION {format.eprint}
{ eprint duplicate$ empty$
    { pop$ "" }
    {
      duplicate$
      ""
        archive duplicate$ empty$ { pop$ archiv.base } 'skip$ if$ *
        "/" *
        swap$ *
        "{" swap$ * "}" *
      swap$
      ""
        archivePrefix duplicate$ empty$ { pop$ "" } { ":" * } if$ *
        swap$ *
        primaryClass  duplicate$ empty$ { pop$ "" } { " [" swap$ * "]" * } if$ *
        "{" swap$ * "}" *
      *
      eprint.command swap$ *
    }
  if$
}

FUNCTION {format.translation}
{ translation duplicate$ empty$
    'skip$
    { ""
      "\translation{" * swap$ * "}" *
      punctuation.space 'punctuation.state :=
    }
  if$
}

FUNCTION {format.url}
{
  url duplicate$ empty$
    { pop$ "" }
    {
      doi empty$
      {
	"\href"
	"{" * swap$ * "}{URL}" *
      }
      { pop$ ""}
      if$
    }
  if$
}

INTEGERS { nameptr namesleft numnames }

FUNCTION {check.speaker}
{ key empty$ 'skip$
  { key nameptr int.to.str$ =
    {
      bolden
    }
      'skip$
    if$
  }
  if$
}


STRINGS  { bibinfo}

FUNCTION {format.names}
{ 'bibinfo :=
  duplicate$ empty$ 'skip$ {
  's :=
  "" 't :=
  #1 'nameptr :=
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { s nameptr
      nameptr #1 >
        { "{ff}" format.name$ duplicate$ empty$ 'skip$
            { tie.or.space.prefix bib.fname.font swap$ * }
          if$
          s nameptr
          "{vv~}{ll}" format.name$ bib.name.font *
          s nameptr
          "{jj}" format.name$ duplicate$ empty$ 'skip$
            { bib.fname.font ", " swap$ * }
          if$
        }
        { "{vv~}{ll}" format.name$ bib.name.font
          s nameptr
          "{ff}{, jj}"
          format.name$ duplicate$ empty$ 'skip$
            { bib.fname.font ", " swap$ * }
          if$
        }
      if$
      *
      bibinfo bibinfo.check
      type$ "presentation" =
        { check.speaker }
        'skip$
      if$
      't :=
      nameptr #1 >
        {
          namesleft #1 >
            {
              ", " *
              t *
            }{
              s nameptr "{ll}" format.name$ duplicate$ "others" =
                { 't := }
                { pop$ }
              if$
              "," *
              t "others" =
                {
                  " " * bbl.etal
                  emphasize
                  *
                }{
                  bbl.and
                  space.word *
                  t *
                }
              if$
            }
          if$
        }
        't
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
  } if$
}

FUNCTION {format.names.ed}
{
  'bibinfo :=
  duplicate$ empty$ 'skip$ {
  's :=
  "" 't :=
  #1 'nameptr :=
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { s nameptr
      "{ff}" format.name$ duplicate$ empty$ 'skip$
        { tie.or.space.prefix bib.fname.font swap$ * }
      if$
      s nameptr
      "{vv~}{ll}" format.name$ bib.name.font *
      s nameptr
      "{jj}" format.name$ duplicate$ empty$ 'skip$
        { bib.fname.font ", " swap$ * }
      if$
      *
      bibinfo bibinfo.check
      't :=
      nameptr #1 >
        {
          namesleft #1 >
            {
              ", " *
              t *
            }{
              s nameptr "{ll}" format.name$ duplicate$ "others" =
                { 't := }
                { pop$ }
              if$
              numnames #2 >
                {
                  "," *
                }
                { skip$ }
              if$
              t "others" =
                {

                  " " * bbl.etal emphasize *
                }{
                  bbl.and
                  space.word * t *
                }
              if$
            }
          if$
        }
        't
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
  } if$
}

FUNCTION {format.key}
{ empty$
    { key field.or.null }
    { "" }
  if$
}

FUNCTION {format.authors}
{ author "author" format.names
  duplicate$ empty$ 'skip$
    { collaboration "collaboration" bibinfo.check
      duplicate$ empty$ 'skip$
        { " (" swap$ * ")" * }
      if$
      *
    }
  if$
  "author" 'bibfield :=
}

FUNCTION {get.bbl.editor}
{ editor num.names$ #1 > 'bbl.editors 'bbl.editor if$
}

FUNCTION {format.editors}
{ editor "editor" format.names duplicate$ empty$ 'skip$
    {
      "," *
      word.space *
      get.bbl.editor
      capitalize
      *
    }
  if$
}

FUNCTION {format.isbn}
{
  isbn "isbn" bibinfo.check
  duplicate$ empty$ 'skip$
    {
      new.block.comma
      "ISBN " swap$ *
    }
  if$
}

FUNCTION {format.issn}
{ issn "issn" bibinfo.check
  duplicate$ empty$ 'skip$
    {
      new.block.comma
      "ISSN " swap$ *
    }
  if$
}

FUNCTION {doi.base}
{
  "http://dx.doi.org/"
}

FUNCTION {doi.command}
{
  "\doi"
}

FUNCTION {doi.command.href}
{
  "\Doi"
}

FUNCTION {url.command.href}
{
  "\urlhref"
}


FUNCTION {format.doi}
{ doi "doi" bibinfo.check
  duplicate$ empty$ 'skip$
    {
      new.block.comma
      doi.command "{" * swap$ * "}" *
    }
  if$
}


FUNCTION {add.url}
{
  duplicate$ empty$ 'skip$
    {
      url duplicate$ empty$ 'pop$
        {
          "{" swap$ * "}" *
          swap$
          "{" swap$ * "}" *
          *
          url.command.href swap$ *
        }
      if$
    }
  if$
}



FUNCTION {add.doi}
{
  duplicate$ empty$ 'skip$
    {
      doi duplicate$ empty$ { pop$ add.url }
        {
          "{" swap$ * "}" *
          swap$
          "{" swap$ * "}" *
          *
          doi.command.href swap$ *
        }
      if$
    }
  if$
}



FUNCTION {select.language}
{ duplicate$ empty$
    'pop$
    { language empty$
        'skip$
        { "{\selectlanguage {" language * "}" * swap$ * "}" * }
      if$
    }
    if$
}

FUNCTION {format.note}
{
 note empty$
    { "" }
    { note #1 #1 substring$
      duplicate$ "{" =
        'skip$
        {
          output.state after.word = output.state after.punctuation = or
            { "l" }
            { "u" }
          if$ change.case$
        }
      if$
      note #2 global.max$ substring$ * "note" bibinfo.check
    }
  if$
}

FUNCTION {bbl.enquote}
{
  "\enquote"
}

FUNCTION {string.enquote}
{
  punctuation.no 'punctuation.state :=
  non.stop {
    block.punctuation
  } { "." } if$
   swap$ pop$
  *
  bbl.enquote "{" * swap$ * "}" *
  word.space *
}

FUNCTION {format.title}
{ title
  duplicate$ empty$ 'skip$ { "t" change.case$ } if$
  duplicate$ "title" bibinfo.check swap$
  duplicate$ empty$ 'pop$
    {
      punctuation.yes 'punctuation.state :=
      string.enquote
      select.language
    }
  if$
}

FUNCTION {end.quote.title}
{ title empty$
    'skip$
    { before.all 'output.state := }
  if$
}

FUNCTION {format.full.names}
{
  's :=
  "" 't :=
  #1 'nameptr :=
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { s nameptr
      "{vv~}{ll}"
      format.name$
      cite.name.font
      't :=
      nameptr #1 >
        {
          namesleft #1 >
            { ", " * t * }
            {
              s nameptr "{ll}" format.name$ duplicate$ "others" =
                {
                  't :=
                }
                'pop$
              if$
              t "others" =
                {
                  " " * bbl.etal
                  emphasize *
                }{
                  numnames #2 > { "," * }{ skip$ } if$
                  bbl.and
                  space.word * t *
                }
              if$
            }
          if$
        }
        't
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

FUNCTION {make.full.names}
{
  key editor author
  type$ "proceedings" =
  type$ "book"        =
  type$ "inbook"      =
  or { pop$ }{ { pop$ "" }{ swap$ pop$ "" swap$ } if$ } if$
  duplicate$ empty$
    { pop$
      duplicate$ empty$
        { pop$
          duplicate$ empty$
            { pop$
              cite$ #1 #3 substring$
            }{
              skip$
            }
          if$
        }
        { swap$ pop$ format.full.names }
      if$
    }
    { swap$ pop$ swap$ pop$ format.full.names }
  if$
}

FUNCTION {year.bibitem}
{
  year duplicate$ empty$
  { pop$ ""
    "????" *
  }{
    skip$
  } if$
  extra.label *
}

FUNCTION {output.bibitem}
{
  newline$
  ""
  label
  *
  ")" *
   make.full.names duplicate$ short.list =
   { pop$ }{ * } if$
  "{" swap$ * "}" *
  "[" swap$ * "]" *
  "{" * cite$ * "}%" *
  "\bibitem"
  swap$ *
  write$ newline$
  "  "
  duplicate$ bbl.open * write$ newline$
  before.all 'output.state :=
  punctuation.yes 'punctuation.state :=
}

FUNCTION {n.dashify}
{
  't :=
  ""
    { t empty$ not }
    { t #1 #1 substring$ "-" =
        { t #1 #2 substring$ "--" = not
            { "--" *
              t #2 global.max$ substring$ 't :=
            }{
                { t #1 #1 substring$ "-" = }
                { "-" *
                  t #2 global.max$ substring$ 't :=
                }
              while$
            }
          if$
        }{
          t #1 #1 substring$ *
          t #2 global.max$ substring$ 't :=
        }
      if$
    }
  while$
}

FUNCTION {word.in}
{
  bbl.in
  word.space *
}

FUNCTION {date.encapsulate}
{
  duplicate$ empty$
    'skip$
    {
      before.all 'output.state :=
      ", " swap$ *
    }
  if$
}

FUNCTION {format.date}
{
  year "year" bibinfo.check duplicate$ empty$
    {
      "empty year in " cite$ * "; set to ????" * warning$
       pop$ "????"
    }
    'skip$
  if$
  month "month" bibinfo.check duplicate$ empty$
    'skip$
    {
      swap$
      word.space * swap$
    }
  if$
  *
  extra.label *
  date.encapsulate
}

FUNCTION {format.date.output.check}
{
 format.date
 "year" output.check
}

FUNCTION {format.date.output}
{
  format.date.output.check
}

FUNCTION {format.btitle}
{
  booktitle duplicate$ empty$ { pop$
      title
  } 'skip$ if$
  "title" bibinfo.check
  duplicate$ empty$ 'skip$
    {
      emphasize
      select.language
    }
  if$
}

FUNCTION {either.or.check}
{ empty$
    'pop$
    { "can't use both " swap$ * " fields in " * cite$ * warning$ }
  if$
}

FUNCTION {editor.check.book}
{ editor empty$ 'skip$
    {
      "can't use both author and editor fields in " cite$ *
      ": try using @inbook instead" *
      warning$
    }
  if$
}

FUNCTION {format.bvolume}
{ volume duplicate$ empty$
    { pop$ "" }
    {
      "volume and number" number either.or.check
      bbl.volume
      capitalize
      swap$
      tie.or.space.prefix "volume" bibinfo.check * *
      series "series" bibinfo.check duplicate$ empty$ 'pop$
        {
          ", "
          * swap$ *
        }
      if$
    }
  if$
}

FUNCTION {format.number}
{
  bbl.number
  output.state after.word = output.state after.punctuation = or
  #1 or
  #0 and
    'skip$
    { capitalize }
  if$
  number tie.or.space.prefix "number" bibinfo.check * *
}

FUNCTION {format.number.series}
{ volume empty$
    { number empty$
        { series field.or.null }
        {
          series empty$
            {
              number "number" bibinfo.check
            }{
              format.number
              series "series" bibinfo.check
              word.space * swap$ *
            }
          if$
        }
      if$
    }
    { "" }
  if$
}

FUNCTION {is.num}
{ chr.to.int$
  duplicate$ "0" chr.to.int$ < not
  swap$ "9" chr.to.int$ > not and
}

FUNCTION {extract.num}
{ duplicate$ 't :=
  "" 's :=
  { t empty$ not }
  { t #1 #1 substring$
    t #2 global.max$ substring$ 't :=
    duplicate$ is.num
      { s swap$ * 's := }
      { pop$ "" 't := }
    if$
  }
  while$
  s empty$
    'skip$
    { pop$ s }
  if$
}

FUNCTION {convert.edition}
{ extract.num "l" change.case$ 's :=
  s "first" = s "1" = or
    { bbl.first 't := }
    { s "second" = s "2" = or
        { bbl.second 't := }
        { s "third" = s "3" = or
            { bbl.third 't := }
            { s "fourth" = s "4" = or
                { bbl.fourth 't := }
                { s "fifth" = s "5" = or
                    { bbl.fifth 't := }
                    { s #1 #1 substring$ is.num
                        { s
                            eng.ord
                        't := }
                        { edition 't := }
                      if$
                    }
                  if$
                }
              if$
            }
          if$
        }
      if$
    }
  if$
  t
}

FUNCTION {format.edition}
{ edition duplicate$ empty$ 'skip$
    {
      convert.edition
      output.state after.word = output.state after.punctuation = or
        { "l" }
        { "t" }
      if$ change.case$
      "edition" bibinfo.check
      word.space * bbl.edition *
    }
  if$
}

INTEGERS { multiresult }
FUNCTION {multi.page.check}
{ 't :=
  #0 'multiresult :=
    { multiresult not
      t empty$ not
      and
    }
    { t #1 #1 substring$
      duplicate$ "-" =
      swap$ duplicate$ "," =
      swap$ "+" =
      or or
        { #1 'multiresult := }
        { t #2 global.max$ substring$ 't := }
      if$
    }
  while$
  multiresult
}

FUNCTION {format.pages}
{ pages duplicate$ empty$
    'skip$
    { duplicate$ multi.page.check
        {
          bbl.pages swap$
          n.dashify
        }{
          bbl.page swap$
        }
      if$
      tie.or.space.prefix
      "pages" bibinfo.check
      * *
    }
  if$
}

FUNCTION {format.book.pages}
{
  pages duplicate$ empty$ 'skip$
    {
      "pages" bibinfo.check word.space bbl.pages * *
    }
  if$
}

FUNCTION {volnum.punct}
{
          ","
  word.space *
}

FUNCTION {format.journal.pages}
{ pages duplicate$ empty$ 'pop$
    { swap$ duplicate$ empty$
        { pop$ pop$ format.pages }
        { volnum.punct *
          swap$
          n.dashify
          "pages" bibinfo.check
          *
        }
      if$
    }
  if$
}

FUNCTION {format.journal.eid}
{ eid "eid" bibinfo.check
  duplicate$ empty$ 'pop$
    { swap$ duplicate$ empty$ 'skip$
        { volnum.punct * }
      if$
      swap$ *
    }
  if$
}

FUNCTION {eid.or.pages}
{
  eid empty$
    { format.journal.pages }
    { format.journal.eid }
  if$
}

FUNCTION {format.ser.vol.num}
{
  series "series" bibinfo.check output
      after.punctuation 'output.state :=
  volume field.or.null
  duplicate$ empty$ 'skip$
    {
      "volume" bibinfo.check
    }
  if$
  bolden
 %%  number "number" bibinfo.check duplicate$ empty$ 'skip$
 %%    {
 %%      swap$ duplicate$ empty$
 %%        { "there's a number but no volume in " cite$ * warning$ }
 %%        'skip$
 %%      if$
 %%      swap$
 %%      "~(" swap$ * ")" *
 %%    }
 %%  if$ *
}

FUNCTION {format.chapter.pages}
{ chapter empty$
    {
      ""
    }
    { type empty$
        {
          bbl.chapter
          capitalize
        }{
          type
          capitalize
          "type" bibinfo.check
        }
      if$
      chapter tie.or.space.prefix
      "chapter" bibinfo.check
      * *
    }
  if$
}

FUNCTION {format.booktitle}
{
  booktitle duplicate$ "booktitle" bibinfo.check swap$
  duplicate$ empty$ 'pop$
    {
      punctuation.yes 'punctuation.state :=
      pop$ emphasize
      select.language
    }
  if$
}

FUNCTION {format.editor.in}
{
  editor "editor" format.names.ed duplicate$ empty$ 'skip$
    {
      bbl.edby
      word.space * swap$ *
    }
  if$
}

FUNCTION {output.article.booktitle}
{
  format.booktitle
      "booktitle" 'bibfield :=
  output
  bookaddress "address" bibinfo.check duplicate$ empty$ 'pop$
    {
      "address" 'bibfield :=
      output.nonnull after.punctuation 'output.state :=
    }
  if$
}

FUNCTION {format.in.ed.booktitle}
{
  format.booktitle duplicate$ empty$ 'pop$
    {
  add.doi
      word.in swap$ * output.nonnull
      bookaddress "address" bibinfo.check output
      format.number.series "series and number" bibinfo.check output
      format.bvolume output
      format.editor.in "editor" bibinfo.check output
    }
  if$
}

FUNCTION {format.in.ed.booktitle.inbook}
{
  format.booktitle duplicate$ empty$ 'pop$
    {
      add.doi
      word.in swap$ * output.nonnull
      bookaddress "address" bibinfo.check output
      format.number.series "series and number" bibinfo.check output
      format.bvolume output
      author empty$ 'skip$
        { format.editor.in "editor" bibinfo.check output }
    if$
    }
  if$
}

FUNCTION {format.thesis.type}
{ type duplicate$ empty$
    'pop$
    { swap$ pop$
      "t" change.case$ "type" bibinfo.check
    }
  if$
}

FUNCTION {format.tr.number}
{ number "number" bibinfo.check
  type duplicate$ empty$
    { pop$ bbl.techrep }
    'skip$
  if$
  "type" bibinfo.check
  swap$ duplicate$ empty$
    { pop$ "t" change.case$ }
    { tie.or.space.prefix * * }
  if$
}

FUNCTION {format.article.crossref}
{
  word.in
  " \cite{" * crossref * "}" *
}

FUNCTION {format.book.crossref}
{ volume duplicate$ empty$
    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
      pop$ word.in
    }
    { bbl.volume
      swap$ tie.or.space.prefix "volume" bibinfo.check * * bbl.of space.word *
    }
  if$
  " \cite{" * crossref * "}" *
}

FUNCTION {format.incoll.inproc.crossref}
{
  word.in
  " \cite{" * crossref * "}" *
}

FUNCTION {format.org.or.pub}
{ 't :=
  ""
  address "address" bibinfo.check
  duplicate$ empty$
    { pop$ t }
    { t duplicate$ empty$
        { pop$ }
        {
          "," word.space *
          * swap$ *
        }
      if$
    }
  if$
  *
  duplicate$ empty$ 'skip$ {
    ""
    "(" * swap$ * ")" *
    after.punctuation 'output.state :=
    punctuation.space 'punctuation.state :=
  } if$
}

FUNCTION {format.publisher.address}
{ publisher "publisher" bibinfo.warn format.org.or.pub
}

FUNCTION {format.organization.address}
{ organization "organization" bibinfo.check format.org.or.pub
}

FUNCTION {format.organization.publisher.address}
{
  publisher empty$
    { format.organization.address }
    { organization "organization" bibinfo.check output
      format.publisher.address
    }
  if$
}

FUNCTION {format.school.address.output}
{
  school  "school"  bibinfo.warn
  address "address" bibinfo.check
  duplicate$ empty$ 'skip$
    {
      swap$
      duplicate$ empty$ 'skip$
        {
          ", " *
        }
      if$
      swap$
    }
  if$
  *
  duplicate$ empty$ 'skip$ { "(" swap$ * ")" * } if$ after.punctuation 'output.state :=
  output
}

FUNCTION {article}
{ output.bibitem
  format.authors
  booktitle empty$ {
      "author" output.check
    }{ output } if$
  author format.key output
  format.date.output.check date.block
  format.title
      "title" 'bibfield :=
  output
  new.block.comma
  output.article.booktitle
  crossref missing$
    {
      journal
      "journal" bibinfo.warn
      pages empty$ 'skip$ { add.doi } if$
      %%pages empty$ 'skip$ {  doi empty$ {add.url} {add.doi} if$ } if$
      "journal" 'bibfield :=
      emphasize
      output
      format.ser.vol.num
      output
    }{
      format.article.crossref output.nonnull
    }
  if$
  eid.or.pages
  %% format.issn output
  pages empty$ {
  format.doi output
  } 'skip$ if$
  %%new.block.comma
  %%new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.translation output
  %%new.block
  %%format.url output
  fin.entry
}

FUNCTION {book}
{ output.bibitem
  author empty$
    {
    }{
      format.authors output.nonnull
      crossref missing$ { editor.check.book } 'skip$ if$
    }
  if$
  format.date.output.check date.block
  format.btitle
  add.doi
  "title" output.check
  format.edition output
  author empty$
    {
      format.editor.in output
      editor format.key output
    }
    {
    }
  if$
      format.number.series output
  crossref missing$
    {
      format.bvolume output
      new.block.comma
      format.publisher.address output
    }{
      new.block.comma
      format.book.crossref output.nonnull
    }
  if$
  format.isbn output
      format.chapter.pages
      output
  new.block.comma
  new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {booklet}
{ output.bibitem
  format.authors output
  author format.key output
  format.date.output date.block
  format.title
  add.doi
  "title" output.check
  new.block.comma
  howpublished "howpublished" bibinfo.check output
  address "address" bibinfo.check output
  format.isbn output
  format.book.pages output
  new.block.comma
  new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {inbook}
{ output.bibitem
  author empty$
    {
       format.editors "editor" output.check
       editor format.key output
    }{
       format.authors output.nonnull
       author format.key output
    }
  if$
  format.date.output.check date.block

  format.title output
  new.block.comma

  crossref missing$
    {
      format.in.ed.booktitle.inbook
      format.chapter.pages
      "chapter"
      output.check
      new.block.comma
      format.edition output
      new.block.comma
      format.publisher.address output
    }{
      format.chapter.pages
      "chapter"
      output.check
      new.block.comma
      format.book.crossref output.nonnull
    }
  if$
  crossref missing$
    { format.isbn output }
    'skip$
  if$
  format.pages "pages" output.check
  new.block.comma
  new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {incollection}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  format.date.output.check date.block
  format.title
  output
  new.block.comma
  crossref missing$
    {
      format.in.ed.booktitle
      format.edition output
      format.chapter.pages output
      format.publisher.address output
      format.isbn output
    }{
      format.incoll.inproc.crossref output.nonnull
      format.chapter.pages output
    }
  if$
  format.pages "pages" output.check
  new.block.comma
  new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {inproceedings}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  format.date.output.check date.block
  format.title
  output
  new.block.comma
  crossref missing$
    {
      format.in.ed.booktitle
      format.organization.publisher.address output
      %%format.isbn output
      %%format.issn output
    }{
      format.incoll.inproc.crossref output.nonnull
    }
  if$
  format.chapter.pages "chapter and pages" output.check
  format.pages "pages" output.check
  new.block.comma
  new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {conference} { inproceedings }
FUNCTION {manual}
{ output.bibitem
  format.authors output
  author format.key output
  format.date.output date.block
  format.btitle
  add.doi
  "title" output.check
      organization "organization" bibinfo.check output
      address "address" bibinfo.check output
  format.edition output
  new.block.comma
  new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {mastersthesis}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  format.date.output.check date.block
  format.btitle
  output
  new.block.comma
  bbl.mthesis
  format.thesis.type
  add.doi
  output.nonnull
  format.school.address.output
  new.block.comma
  new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {misc}
{ output.bibitem
  format.authors output
  author format.key output
  format.date.output
  date.block
  format.title
  add.doi
  output
  new.block.comma
  howpublished "howpublished" bibinfo.check output
  new.block.comma
  new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {phdthesis}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  format.date.output.check date.block
  format.btitle
  output
  new.block.comma
  bbl.phdthesis
  format.thesis.type
  add.doi
  output.nonnull
  format.school.address.output
  new.block.comma
  new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {presentation}
{ output.bibitem
  format.authors output
  author format.key output
  new.block.comma
  format.title output
  new.block.comma
  format.organization.address "organization and address" output.check
  month "month" output.check
  year "year" output.check
  new.block.comma
  new.sentence.comma
  format.note output
  new.sentence
  type missing$ 'skip$
    {"(" type capitalize * ")" * output}
  if$
  new.block.comma format.url output
  fin.entry
}

FUNCTION {proceedings}
{ output.bibitem
  format.editors output
  editor format.key output
  format.date.output.check date.block
  format.btitle
  add.doi
  "title" output.check
      bookaddress "address" bibinfo.check output
  format.number.series output
  format.bvolume output
  format.organization.publisher.address output
  %%format.isbn output
  %%format.issn output
  new.block.comma
  new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {techreport}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  format.date.output.check date.block
  format.btitle
  add.doi
  "title" output.check
  new.block.comma
  format.tr.number
  output.nonnull
  institution "institution" bibinfo.warn
  format.org.or.pub output
  new.block.comma
  new.sentence.comma
  %%format.note output
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {unpublished}
{ output.bibitem
  format.authors "author" output.check
  author format.key output
  format.date.output date.block
  format.title
  add.doi
  "title" output.check
  new.block.comma
  new.sentence.comma
  %%format.note "note" output.check
  %%format.eprint output
  %%format.url output
  fin.entry
}

FUNCTION {default.type} { misc }
READ
FUNCTION {sortify}
{ purify$
  "l" change.case$
}

INTEGERS { len }
FUNCTION {chop.word}
{ 's :=
  'len :=
  s #1 len substring$ =
    { s len #1 + global.max$ substring$ }
    's
  if$
}

FUNCTION {format.lab.names}
{ 's :=
  "" 't :=
  s #1
  "{vv~}{ll}"
  format.name$
  cite.name.font
  s num.names$ duplicate$
  #2 >
    { pop$
      word.space * bbl.etal
      emphasize
      *
    }{
      #2 <
        'skip$
        {
          s #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
            {
              word.space * bbl.etal
              emphasize
              *
            }{
              bbl.and space.word *
              s #2 "{vv~}{ll}" format.name$
              cite.name.font
              *
            }
          if$
        }
      if$
    }
  if$
}

FUNCTION {author.key.label}
{ author empty$
    { key empty$
        { cite$ #1 #3 substring$ }
        'key
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {author.editor.key.label}
{ author empty$
    { editor empty$
        { key empty$
            { cite$ #1 #3 substring$ }
            'key
          if$
        }
        { editor format.lab.names }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {editor.key.label}
{ editor empty$
    { key empty$
        { cite$ #1 #3 substring$ }
        'key
      if$
    }
    { editor format.lab.names }
  if$
}

FUNCTION {calc.short.authors}
{ type$ "book" =
  type$ "inbook" =
  or
    'author.editor.key.label
    { type$ "proceedings" =
        'editor.key.label
        'author.key.label
      if$
    }
  if$
  'short.list :=
}

FUNCTION {calc.label}
{ calc.short.authors
  short.list
  "("
  *
  year duplicate$ empty$
  short.list key field.or.null = or
    {
      pop$ ""
       "????" *
    }{
      skip$
    }
  if$
  *
  'label :=
}

FUNCTION {sort.format.names}
{ 's :=
  #1 'nameptr :=
  ""
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { s nameptr
      "{ll{ }}{  ff{ }}{  jj{ }}"
      format.name$ 't :=
      nameptr #1 >
        {
          "   "  *
          namesleft #1 = t "others" = and
            { "zzzzz" * }
            {
              t sortify *
            }
          if$
        }
        { t sortify * }
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

FUNCTION {sort.format.title}
{ 't :=
  "A " #2
    "An " #3
      "The " #4 t chop.word
    chop.word
  chop.word
  sortify
  #1 global.max$ substring$
}

FUNCTION {author.sort}
{ author empty$
    { key empty$
        { "to sort, need author or key in " cite$ * warning$
          ""
        }
        { key sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {author.editor.sort}
{ author empty$
    { editor empty$
        { key empty$
            { "to sort, need author, editor, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { editor sort.format.names }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {editor.sort}
{ editor empty$
    { key empty$
        { "to sort, need editor or key in " cite$ * warning$
          ""
        }
        { key sortify }
      if$
    }
    { editor sort.format.names }
  if$
}

FUNCTION {presort}
{ calc.label
  label sortify
  "    "
  *
  type$ "book" =
  type$ "inbook" =
  or
    'author.editor.sort
    { type$ "proceedings" =
        'editor.sort
        'author.sort
      if$
    }
  if$
  #1 entry.max$ substring$
  'sort.label :=
  sort.label
  *
  "    "
  *
  title field.or.null
  sort.format.title
  *
  #1 entry.max$ substring$
  'sort.key$ :=
}

ITERATE {presort}
SORT
STRINGS { last.label next.extra }
INTEGERS { last.extra.num number.label }
FUNCTION {initialize.extra.label.stuff}
{ #0 int.to.chr$ 'last.label :=
  "" 'next.extra :=
  #0 'last.extra.num :=
  #0 'number.label :=
}

FUNCTION {forward.pass}
{ last.label label =
    { last.extra.num #1 + 'last.extra.num :=
      last.extra.num int.to.chr$ 'extra.label :=
    }
    { "a" chr.to.int$ 'last.extra.num :=
      "" 'extra.label :=
      label 'last.label :=
    }
  if$
  number.label #1 + 'number.label :=
}

FUNCTION {reverse.pass}
{ next.extra "b" =
    { "a" 'extra.label := }
    'skip$
  if$
  extra.label 'next.extra :=
  extra.label
  duplicate$ empty$
    'skip$
    { "{\natexlab{" swap$ * "}}" * }
  if$
  'extra.label :=
  label extra.label * 'label :=
}

EXECUTE {initialize.extra.label.stuff}
ITERATE {forward.pass}
REVERSE {reverse.pass}
FUNCTION {bib.sort.order}
{ sort.label
  "    "
  *
  year
  field.or.null sortify
  *
  "    "
  *
  title field.or.null
  sort.format.title
  *
  #1 entry.max$ substring$
  'sort.key$ :=
}

ITERATE {bib.sort.order}
SORT
FUNCTION {init.bib.eprint}
{
    "\texttt{"
  pop$
  "\providecommand \url  [0]{\begingroup\@sanitize \@url }%" write$ newline$
  "\providecommand \@url [1]{\endgroup\@href {#1}{" "}}%" bbl.url.prefix swap$ * * write$ newline$
  "\providecommand " " [0]{URL }%" bbl.url.prefix swap$ * * write$ newline$
  eprint.command "\providecommand " swap$ * "[0]{\href }%" * write$ newline$
}

FUNCTION {init.bib.doi}
{
  "\@ifxundefined \urlstyle {%"  write$ newline$
  "  \providecommand \doi [1]{doi:\discretionary{}{}{}#1}%"  write$ newline$
  "}{%"  write$ newline$
  "  \providecommand \doi [0]{doi:\discretionary{}{}{}\begingroup \urlstyle{rm}\Url }%"
  write$ newline$
  "}%"  write$ newline$
  "\providecommand \doibase [0]{" doi.base * "}%" * write$ newline$
  doi.command.href "\providecommand " swap$ * "[1]{\href{\doibase#1}}%" * write$ newline$
  url.command.href "\providecommand " swap$ * "[1]{\href{#1}}%" * write$ newline$
}

FUNCTION {init.bib.hypertex}
{
  "\providecommand\href[0]{\@sanitize\@href}%" write$ newline$
  "\providecommand\@href[1]{\endgroup\@@startlink{#1}\endgroup\@@href}%" write$ newline$
  "\providecommand\@@href[1]{#1\@@endlink}%" write$ newline$
  "\providecommand \@sanitize [0]{\begingroup\catcode`\&12\catcode`\#12\relax}%" write$ newline$
  "\@ifxundefined \pdfoutput {\@firstoftwo}{%" write$ newline$
  " \@ifnum{\z@=\pdfoutput}{\@firstoftwo}{\@secondoftwo}%" write$ newline$
  "}{%" write$ newline$
  " \providecommand\@@startlink[1]{\leavevmode\special{html:<a href=" quote$ * "#1" * quote$ * ">}}%" * write$ newline$
  " \providecommand\@@endlink[0]{\special{html:</a>}}%" write$ newline$
  "}{%" write$ newline$
  " \providecommand\@@startlink[1]{%" write$ newline$
  "  \leavevmode" write$ newline$
  "  \pdfstartlink" write$ newline$
  "   attr{/Border[0 0 1 ]/H/I/C[0 1 1]}%" write$ newline$
  "   user{/Subtype/Link/A<</Type/Action/S/URI/URI(#1)>>}%" write$ newline$
  "  \relax" write$ newline$
  " }%" write$ newline$
  " \providecommand\@@endlink[0]{\pdfendlink}%" write$ newline$
  "}%" write$ newline$
}

FUNCTION {init.bib.namefont}
{
  "\providecommand \bibnamefont  [1]{#1}%"  write$ newline$
  "\providecommand \bibfnamefont [1]{#1}%" write$ newline$
  "\providecommand \citenamefont [1]{#1}%"  write$ newline$
}

FUNCTION {init.bib.quote}
{
  "\providecommand " bbl.enquote * " [1]{" *
  "``" "''"
  "#1" swap$ "}%" * * * * write$ newline$
}

FUNCTION {init.bib.ay}
{
  "\providecommand \natexlab [1]{#1}%"
  write$ newline$
}

FUNCTION {init.bib.annote}
{
  "\providecommand \bibAnnote [3]{%" write$ newline$
  "  " bbl.shut * "{#1}%" * write$ newline$
  "  \begin{quotation}\noindent" write$ newline$
  "    \textsc{Key:}\ #2\\\textsc{Annotation:}\ #3%" write$ newline$
  "  \end{quotation}%" write$ newline$
  "}%" write$ newline$
  "\providecommand \bibAnnoteFile [2]{%" write$ newline$
  "  \IfFileExists{#2}{\bibAnnote {#1} {#2} {\input{#2}}}{}%" write$ newline$
  "}%" write$ newline$
  "\providecommand \typeout [0]{\immediate \write \m@ne }%" write$ newline$
}

FUNCTION {init.bib.bibinfo}
{
  bibinfo.command  "\providecommand " swap$ * " [0]{\@secondoftwo}%" * write$ newline$
  bibfield.command "\providecommand " swap$ * " [0]{\@secondoftwo}%" * write$ newline$
}

FUNCTION {init.bib.lang}
{
  "\providecommand \selectlanguage [0]{\@gobble}%" write$ newline$
}

FUNCTION {init.bib.endbibitem}
{
  "\providecommand " bbl.open * "[0]{}%" *           write$ newline$
  "\providecommand \bibitemStop [0]{}%"               write$ newline$
  "\providecommand \bibitemNoStop [0]{.\EOS\space}%"  write$ newline$
  "\providecommand \EOS [0]{\spacefactor3000\relax}%"   write$ newline$
}

FUNCTION {init.bib.translation}
{
  "\providecommand \translation [1]{[#1]}%" write$ newline$
}

FUNCTION {warn.bib}
{
}

FUNCTION {init.bib}
{
  warn.bib
  "\makeatletter" write$ newline$
  "\providecommand \@ifxundefined [1]{%"     write$ newline$
  " \ifx #1\undefined \expandafter \@firstoftwo" write$ newline$
  " \else \expandafter \@secondoftwo"      write$ newline$
  "\fi"                                    write$ newline$
  "}%"                                     write$ newline$
  "\providecommand \@ifnum [1]{%"          write$ newline$
  " \ifnum #1\expandafter \@firstoftwo"    write$ newline$
  " \else \expandafter \@secondoftwo"      write$ newline$
  "\fi"                                    write$ newline$
  "}%"                                     write$ newline$
  init.bib.ay
  init.bib.quote
  init.bib.namefont
  init.bib.hypertex
  init.bib.eprint
  init.bib.doi
  init.bib.annote
  init.bib.lang
  init.bib.bibinfo
  init.bib.translation
  init.bib.endbibitem
  "\providecommand " bbl.shut * " [1]{\csname bibitem#1\endcsname}%" * write$ newline$
  "%</preamble>" write$
}

FUNCTION {begin.bib}
{
  id.bst duplicate$ top$ "%" swap$ * write$ newline$
  preamble$ empty$
    'skip$
    { preamble$ write$ newline$ }
  if$
  "\begin{thebibliography}{"
  number.label int.to.str$
  * "}%" *
  write$ newline$
  init.bib
}

EXECUTE {begin.bib}
EXECUTE {init.state.consts}
ITERATE {call.type$}
FUNCTION {end.bib}
{ newline$
  "\end{thebibliography}%"
  write$ newline$
}

EXECUTE {end.bib}
%% End of customized bst file
%%
%% End of file `iitbauthyr.bst'.
